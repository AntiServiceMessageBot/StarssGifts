import asyncio
import logging
import sqlite3
import random
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from collections import defaultdict

from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = "7739594735:AAENvoaOK01JNRl5CXfqzTzlXGLUun715Bk"
ADMIN_GROUP_ID = -1001234567890
CHANNEL_ID = "@your_channel"
OWNER_ID = 5261397307

bot = Bot(token=TOKEN)
dp = Dispatcher(storage=MemoryStorage())

# –≠–º–æ–¥–∑–∏
EMOJI = {
    "main": "üéÆ", "nft": "üéÅ", "stars": "‚≠ê", "premium": "üëë",
    "auction": "üî®", "reviews": "üìù", "support": "üÜò", "settings": "‚öôÔ∏è",
    "admin": "üë®‚Äçüíº", "back": "üîô", "success": "‚úÖ", "error": "‚ùå",
    "warning": "‚ö†Ô∏è", "money": "üí∞", "time": "‚è∞", "user": "üë§"
}

# –°–æ—Å—Ç–æ—è–Ω–∏—è
class UserStates(StatesGroup):
    main_menu = State()
    buy_nft = State()
    buy_stars = State()
    buy_premium = State()

class AdminStates(StatesGroup):
    admin_menu = State()
    add_nft = State()
    add_nft_name = State()
    add_nft_price = State()
    add_nft_link = State()

# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
class Database:
    def __init__(self):
        self.conn = sqlite3.connect("bot.db", check_same_thread=False)
        self.cursor = self.conn.cursor()
        self.init_db()
    
    def init_db(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                subscribed INTEGER DEFAULT 0,
                banned INTEGER DEFAULT 0
            )
        ''')
        
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS staff (
                user_id INTEGER PRIMARY KEY,
                role TEXT
            )
        ''')
        
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS nft_items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                price REAL,
                link TEXT
            )
        ''')
        
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS orders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                order_type TEXT,
                details TEXT,
                status TEXT DEFAULT 'a'
            )
        ''')
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞
        self.cursor.execute('INSERT OR IGNORE INTO staff VALUES (?, ?)', (OWNER_ID, 'owner'))
        
        self.conn.commit()
    
    def add_user(self, user_id: int, username: str):
        self.cursor.execute('INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)', (user_id, username))
        self.conn.commit()
    
    def is_admin(self, user_id: int) -> bool:
        self.cursor.execute('SELECT role FROM staff WHERE user_id = ?', (user_id,))
        result = self.cursor.fetchone()
        return result is not None
    
    def is_owner(self, user_id: int) -> bool:
        self.cursor.execute('SELECT role FROM staff WHERE user_id = ?', (user_id,))
        result = self.cursor.fetchone()
        return result and result[0] == 'owner'
    
    def add_nft(self, name: str, price: float, link: str):
        self.cursor.execute('INSERT INTO nft_items (name, price, link) VALUES (?, ?, ?)', (name, price, link))
        self.conn.commit()
    
    def get_nft_items(self) -> List[Dict]:
        self.cursor.execute('SELECT id, name, price, link FROM nft_items')
        return [
            {'id': row[0], 'name': row[1], 'price': row[2], 'link': row[3]}
            for row in self.cursor.fetchall()
        ]
    
    def create_order(self, user_id: int, order_type: str, details: str = "") -> int:
        self.cursor.execute(
            'INSERT INTO orders (user_id, order_type, details) VALUES (?, ?, ?)',
            (user_id, order_type, details)
        )
        self.conn.commit()
        return self.cursor.lastrowid
    
    def update_order_status(self, order_id: int, status: str):
        self.cursor.execute('UPDATE orders SET status = ? WHERE id = ?', (status, order_id))
        self.conn.commit()
    
    def get_order(self, order_id: int) -> Optional[Dict]:
        self.cursor.execute('SELECT * FROM orders WHERE id = ?', (order_id,))
        row = self.cursor.fetchone()
        if row:
            columns = [desc[0] for desc in self.cursor.description]
            return dict(zip(columns, row))
        return None
    
    def close(self):
        self.conn.close()

db = Database()

# –£—Ç–∏–ª–∏—Ç—ã
async def check_subscription(user_id: int) -> bool:
    try:
        member = await bot.get_chat_member(CHANNEL_ID, user_id)
        return member.status in ['member', 'administrator', 'creator']
    except:
        return True  # –î–ª—è —Ç–µ—Å—Ç–∞

async def send_to_admins(text: str, keyboard: InlineKeyboardMarkup = None):
    try:
        await bot.send_message(ADMIN_GROUP_ID, text, reply_markup=keyboard, parse_mode="Markdown")
    except:
        pass

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
def get_main_menu(user_id: int):
    buttons = [
        [InlineKeyboardButton(text=f"{EMOJI['nft']} –ö—É–ø–∏—Ç—å NFT", callback_data="buy_nft")],
        [InlineKeyboardButton(text=f"{EMOJI['stars']} –ö—É–ø–∏—Ç—å –∑–≤–µ–∑–¥—ã", callback_data="buy_stars")],
        [InlineKeyboardButton(text=f"{EMOJI['premium']} –ö—É–ø–∏—Ç—å –ø—Ä–µ–º–∏—É–º", callback_data="buy_premium")],
        [InlineKeyboardButton(text=f"{EMOJI['support']} –ü–æ–¥–¥–µ—Ä–∂–∫–∞", callback_data="support")]
    ]
    
    if db.is_admin(user_id):
        buttons.append([InlineKeyboardButton(text=f"{EMOJI['admin']} –ê–¥–º–∏–Ω", callback_data="admin")])
    
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_order_keyboard(order_id: int):
    buttons = [
        [
            InlineKeyboardButton(text="‚úÖ –í–∑—è—Ç—å", callback_data=f"take_{order_id}"),
            InlineKeyboardButton(text="‚ùå –°–ü–ê–ú", callback_data=f"spam_{order_id}")
        ],
        [
            InlineKeyboardButton(text="üí∞ –ù–µ –æ–ø–ª–∞—Ç–∏–ª", callback_data=f"nopay_{order_id}"),
            InlineKeyboardButton(text="‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=f"complete_{order_id}")
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
@dp.message(Command("start"))
async def start_cmd(message: Message, state: FSMContext):
    user_id = message.from_user.id
    
    if not await check_subscription(user_id):
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", url=f"https://t.me/{CHANNEL_ID[1:]}")],
            [InlineKeyboardButton(text="‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å", callback_data="check_sub")]
        ])
        await message.answer(f"{EMOJI['warning']} –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª!", reply_markup=keyboard)
        return
    
    db.add_user(user_id, message.from_user.username)
    
    await state.set_state(UserStates.main_menu)
    await message.answer(
        f"{EMOJI['main']} *–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=get_main_menu(user_id),
        parse_mode="Markdown"
    )

@dp.callback_query(F.data == "check_sub")
async def check_sub(callback: CallbackQuery, state: FSMContext):
    if await check_subscription(callback.from_user.id):
        await callback.message.edit_text(
            f"{EMOJI['success']} *–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=get_main_menu(callback.from_user.id),
            parse_mode="Markdown"
        )
    else:
        await callback.answer("‚ùå –í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã!", show_alert=True)

@dp.callback_query(F.data == "back")
async def back_to_menu(callback: CallbackQuery, state: FSMContext):
    await state.set_state(UserStates.main_menu)
    await callback.message.edit_text(
        f"{EMOJI['main']} *–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=get_main_menu(callback.from_user.id),
        parse_mode="Markdown"
    )

# NFT
@dp.callback_query(F.data == "buy_nft")
async def buy_nft(callback: CallbackQuery, state: FSMContext):
    await state.set_state(UserStates.buy_nft)
    
    nft_items = db.get_nft_items()
    builder = InlineKeyboardBuilder()
    
    for item in nft_items[:8]:  # –ü–µ—Ä–≤—ã–µ 8
        builder.button(text=f"{item['name']} | {item['price']}$", callback_data=f"nft_{item['id']}")
    
    builder.button(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="back")
    builder.adjust(1)
    
    text = f"{EMOJI['nft']} *NFT –ø–æ–¥–∞—Ä–∫–∏*\n\n–í—ã–±–µ—Ä–∏—Ç–µ:"
    await callback.message.edit_text(text, reply_markup=builder.as_markup(), parse_mode="Markdown")

@dp.callback_query(F.data.startswith("nft_"))
async def select_nft(callback: CallbackQuery):
    nft_id = int(callback.data.split("_")[1])
    nft_items = db.get_nft_items()
    item = next((i for i in nft_items if i['id'] == nft_id), None)
    
    if item:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üõí –ö—É–ø–∏—Ç—å", callback_data=f"buynft_{nft_id}")],
            [InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="buy_nft")]
        ])
        
        await callback.message.edit_text(
            f"{EMOJI['nft']} *{item['name']}*\n\n"
            f"üí∞ –¶–µ–Ω–∞: {item['price']}$\n"
            f"üîó –°—Å—ã–ª–∫–∞: {item['link']}",
            reply_markup=keyboard,
            parse_mode="Markdown"
        )

@dp.callback_query(F.data.startswith("buynft_"))
async def buy_nft_item(callback: CallbackQuery):
    nft_id = int(callback.data.split("_")[1])
    order_id = db.create_order(
        user_id=callback.from_user.id,
        order_type="nft",
        details=f"NFT ID: {nft_id}"
    )
    
    order = db.get_order(order_id)
    text = f"""üÜï *–ù–û–í–´–ô –ó–ê–ö–ê–ó*

1. –ù–æ–º–µ—Ä: #{order['id']}
2. ID: `{order['user_id']}`
3. –ù–∏–∫: @{callback.from_user.username or '–ù–µ—Ç'}
4. –ü—Ä–∏—á–∏–Ω–∞: NFT
5. –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
6. –°–æ—Å—Ç–æ—è–Ω–∏–µ: ‚ùå –ù–µ –≤–∑—è—Ç–æ"""
    
    await send_to_admins(text, get_order_keyboard(order_id))
    
    await callback.message.edit_text(
        f"{EMOJI['success']} –ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω! –° –≤–∞–º–∏ —Å–∫–æ—Ä–æ —Å–≤—è–∂—É—Ç—Å—è.",
        parse_mode="Markdown"
    )

# –ó–≤–µ–∑–¥—ã
@dp.callback_query(F.data == "buy_stars")
async def buy_stars(callback: CallbackQuery, state: FSMContext):
    await state.set_state(UserStates.buy_stars)
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="50 –∑–≤–µ–∑–¥ - 99‚ÇΩ", callback_data="stars_1")],
        [InlineKeyboardButton(text="100 –∑–≤–µ–∑–¥ - 199‚ÇΩ", callback_data="stars_2")],
        [InlineKeyboardButton(text="300 –∑–≤–µ–∑–¥ - 499‚ÇΩ", callback_data="stars_3")],
        [InlineKeyboardButton(text="500 –∑–≤–µ–∑–¥ - 999‚ÇΩ", callback_data="stars_4")],
        [InlineKeyboardButton(text="1000 –∑–≤–µ–∑–¥ - 1999‚ÇΩ", callback_data="stars_5")],
        [InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="back")]
    ])
    
    await callback.message.edit_text(
        f"{EMOJI['stars']} *Telegram Stars*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç:",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@dp.callback_query(F.data.startswith("stars_"))
async def select_stars(callback: CallbackQuery):
    order_id = db.create_order(
        user_id=callback.from_user.id,
        order_type="stars",
        details=callback.data
    )
    
    order = db.get_order(order_id)
    text = f"""üÜï *–ù–û–í–´–ô –ó–ê–ö–ê–ó*

1. –ù–æ–º–µ—Ä: #{order['id']}
2. ID: `{order['user_id']}`
3. –ù–∏–∫: @{callback.from_user.username or '–ù–µ—Ç'}
4. –ü—Ä–∏—á–∏–Ω–∞: –ó–í–ï–ó–î–´
5. –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
6. –°–æ—Å—Ç–æ—è–Ω–∏–µ: ‚ùå –ù–µ –≤–∑—è—Ç–æ"""
    
    await send_to_admins(text, get_order_keyboard(order_id))
    
    await callback.message.edit_text(
        f"{EMOJI['success']} –ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω! –° –≤–∞–º–∏ —Å–∫–æ—Ä–æ —Å–≤—è–∂—É—Ç—Å—è.",
        parse_mode="Markdown"
    )

# –ü—Ä–µ–º–∏—É–º
@dp.callback_query(F.data == "buy_premium")
async def buy_premium(callback: CallbackQuery, state: FSMContext):
    await state.set_state(UserStates.buy_premium)
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="1 –º–µ—Å—è—Ü - 6.2$", callback_data="premium_1")],
        [InlineKeyboardButton(text="3 –º–µ—Å—è—Ü–∞ - 10$", callback_data="premium_2")],
        [InlineKeyboardButton(text="6 –º–µ—Å—è—Ü–µ–≤ - 18$", callback_data="premium_3")],
        [InlineKeyboardButton(text="1 –≥–æ–¥ - 35$", callback_data="premium_4")],
        [InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="back")]
    ])
    
    await callback.message.edit_text(
        f"{EMOJI['premium']} *Telegram Premium*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥:",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@dp.callback_query(F.data.startswith("premium_"))
async def select_premium(callback: CallbackQuery):
    order_id = db.create_order(
        user_id=callback.from_user.id,
        order_type="premium",
        details=callback.data
    )
    
    order = db.get_order(order_id)
    text = f"""üÜï *–ù–û–í–´–ô –ó–ê–ö–ê–ó*

1. –ù–æ–º–µ—Ä: #{order['id']}
2. ID: `{order['user_id']}`
3. –ù–∏–∫: @{callback.from_user.username or '–ù–µ—Ç'}
4. –ü—Ä–∏—á–∏–Ω–∞: PREMIUM
5. –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
6. –°–æ—Å—Ç–æ—è–Ω–∏–µ: ‚ùå –ù–µ –≤–∑—è—Ç–æ"""
    
    await send_to_admins(text, get_order_keyboard(order_id))
    
    await callback.message.edit_text(
        f"{EMOJI['success']} –ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω! –° –≤–∞–º–∏ —Å–∫–æ—Ä–æ —Å–≤—è–∂—É—Ç—Å—è.",
        parse_mode="Markdown"
    )

# –ü–æ–¥–¥–µ—Ä–∂–∫–∞
@dp.callback_query(F.data == "support")
async def support(callback: CallbackQuery):
    order_id = db.create_order(
        user_id=callback.from_user.id,
        order_type="support",
        details="–ó–∞–ø—Ä–æ—Å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É"
    )
    
    order = db.get_order(order_id)
    text = f"""üÜï *–ü–û–î–î–ï–†–ñ–ö–ê*

1. –ù–æ–º–µ—Ä: #{order['id']}
2. ID: `{order['user_id']}`
3. –ù–∏–∫: @{callback.from_user.username or '–ù–µ—Ç'}
4. –ü—Ä–∏—á–∏–Ω–∞: –ü–û–î–î–ï–†–ñ–ö–ê
5. –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
6. –°–æ—Å—Ç–æ—è–Ω–∏–µ: ‚ùå –ù–µ –≤–∑—è—Ç–æ"""
    
    await send_to_admins(text, get_order_keyboard(order_id))
    
    await callback.message.edit_text(
        f"{EMOJI['success']} –í–∞—à –∑–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω! –û–∂–∏–¥–∞–π—Ç–µ –æ—Ç–≤–µ—Ç–∞.",
        parse_mode="Markdown"
    )

# –ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å
@dp.callback_query(F.data == "admin")
async def admin_panel(callback: CallbackQuery, state: FSMContext):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    await state.set_state(AdminStates.admin_menu)
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å NFT", callback_data="add_nft")],
        [InlineKeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="stats")],
        [InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="back")]
    ])
    
    await callback.message.edit_text(
        f"{EMOJI['admin']} *–ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@dp.callback_query(F.data == "add_nft")
async def add_nft_start(callback: CallbackQuery, state: FSMContext):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    await state.set_state(AdminStates.add_nft_name)
    await callback.message.edit_text(
        f"{EMOJI['nft']} *–î–æ–±–∞–≤–ª–µ–Ω–∏–µ NFT*\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–æ–¥–∞—Ä–∫–∞:",
        parse_mode="Markdown"
    )

@dp.message(AdminStates.add_nft_name)
async def add_nft_name(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(AdminStates.add_nft_price)
    await message.answer(f"{EMOJI['money']} –í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É –≤ $:")

@dp.message(AdminStates.add_nft_price)
async def add_nft_price(message: Message, state: FSMContext):
    try:
        price = float(message.text)
        await state.update_data(price=price)
        await state.set_state(AdminStates.add_nft_link)
        await message.answer(f"{EMOJI['link']} –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ–¥–∞—Ä–æ–∫:")
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!")

@dp.message(AdminStates.add_nft_link)
async def add_nft_link(message: Message, state: FSMContext):
    data = await state.get_data()
    db.add_nft(data['name'], data['price'], message.text)
    
    await message.answer(f"{EMOJI['success']} NFT –¥–æ–±–∞–≤–ª–µ–Ω!")
    await state.clear()

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫–∞–∑–æ–≤ –∞–¥–º–∏–Ω–∞–º–∏
@dp.callback_query(F.data.startswith("take_"))
async def take_order(callback: CallbackQuery):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    order_id = int(callback.data.split("_")[1])
    db.update_order_status(order_id, "b")  # –í –ø—Ä–æ—Ü–µ—Å—Å–µ
    
    order = db.get_order(order_id)
    text = f"""üîÑ *–ó–ê–ö–ê–ó –í –†–ê–ë–û–¢–ï*

1. –ù–æ–º–µ—Ä: #{order['id']}
2. ID: `{order['user_id']}`
3. –ù–∏–∫: @{callback.from_user.username or '–ù–µ—Ç'}
4. –ü—Ä–∏—á–∏–Ω–∞: {order['order_type'].upper()}
5. –î–∞—Ç–∞: {order['id']}
6. –°–æ—Å—Ç–æ—è–Ω–∏–µ: üîÑ –í –ø—Ä–æ—Ü–µ—Å—Å–µ
7. –ê–¥–º–∏–Ω: @{callback.from_user.username}"""
    
    await callback.message.edit_text(text, reply_markup=get_order_keyboard(order_id), parse_mode="Markdown")
    await callback.answer("‚úÖ –ó–∞–∫–∞–∑ –≤–∑—è—Ç!")

@dp.callback_query(F.data.startswith("complete_"))
async def complete_order(callback: CallbackQuery):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    order_id = int(callback.data.split("_")[1])
    db.update_order_status(order_id, "s")  # –ó–∞–≤–µ—Ä—à–µ–Ω–æ
    await callback.answer("‚úÖ –ó–∞–∫–∞–∑ –∑–∞–≤–µ—Ä—à–µ–Ω!")

@dp.callback_query(F.data.startswith("spam_"))
async def spam_order(callback: CallbackQuery):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    order_id = int(callback.data.split("_")[1])
    db.update_order_status(order_id, "z")  # –°–ø–∞–º
    
    order = db.get_order(order_id)
    try:
        await bot.send_message(order['user_id'], f"{EMOJI['error']} –û—à–∏–±–∫–∞. –°–≤—è–∑—å —Å –±–∞–∑–æ–π...")
    except:
        pass
    
    await callback.answer("üö´ –ü–æ–º–µ—á–µ–Ω–æ –∫–∞–∫ —Å–ø–∞–º!")

@dp.callback_query(F.data.startswith("nopay_"))
async def nopay_order(callback: CallbackQuery):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    order_id = int(callback.data.split("_")[1])
    db.update_order_status(order_id, "g")  # –ù–µ –æ–ø–ª–∞—Ç–∏–ª
    
    order = db.get_order(order_id)
    try:
        await bot.send_message(order['user_id'], f"{EMOJI['error']} –í—ã –Ω–µ –æ–ø–ª–∞—Ç–∏–ª–∏ –∑–∞–∫–∞–∑!")
    except:
        pass
    
    await callback.answer("üí∞ –ù–µ –æ–ø–ª–∞—Ç–∏–ª!")

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def main():
    logging.basicConfig(level=logging.INFO)
    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    finally:
        db.close()
