import asyncio
import sqlite3
from datetime import datetime
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message, CallbackQuery

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = "7739594735:AAENvoaOK01JNRl5CXfqzTzlXGLUun715Bk"
ADMIN_GROUP_ID = -  # ID –≥—Ä—É–ø–ø—ã –∞–¥–º–∏–Ω–æ–≤ (–æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –µ—Å–ª–∏ –Ω–µ—Ç)
OWNER_ID = 5261397307  # –í–∞—à ID –≤ Telegram

bot = Bot(token=TOKEN)
dp = Dispatcher(storage=MemoryStorage())

# –≠–º–æ–¥–∑–∏
EMOJI = {
    "main": "üéÆ", "nft": "üéÅ", "stars": "‚≠ê", "premium": "üëë",
    "support": "üÜò", "admin": "üë®‚Äçüíº", "back": "üîô", "success": "‚úÖ",
    "error": "‚ùå", "money": "üí∞"
}

# –°–æ—Å—Ç–æ—è–Ω–∏—è
class UserStates(StatesGroup):
    main_menu = State()
    buy_nft = State()

class AdminStates(StatesGroup):
    admin_menu = State()
    add_nft = State()
    add_nft_name = State()
    add_nft_price = State()
    add_nft_link = State()

# –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
class Database:
    def __init__(self):
        self.conn = sqlite3.connect("bot.db", check_same_thread=False)
        self.cursor = self.conn.cursor()
        self.init_db()
    
    def init_db(self):
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                joined_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # –ê–¥–º–∏–Ω—ã
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS staff (
                user_id INTEGER PRIMARY KEY,
                role TEXT
            )
        ''')
        
        # NFT —Ç–æ–≤–∞—Ä—ã
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS nft_items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                price REAL,
                link TEXT
            )
        ''')
        
        # –ó–∞–∫–∞–∑—ã
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS orders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                order_type TEXT,
                details TEXT,
                status TEXT DEFAULT 'a',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∫–∞–∫ –∞–¥–º–∏–Ω–∞
        self.cursor.execute('INSERT OR IGNORE INTO staff VALUES (?, ?)', (OWNER_ID, 'owner'))
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ NFT
        test_nft = [
            ("Golden NFT", 100.0, "https://example.com/nft1"),
            ("Silver NFT", 50.0, "https://example.com/nft2"),
            ("Bronze NFT", 25.0, "https://example.com/nft3"),
        ]
        for name, price, link in test_nft:
            self.cursor.execute('INSERT OR IGNORE INTO nft_items (name, price, link) VALUES (?, ?, ?)', 
                              (name, price, link))
        
        self.conn.commit()
    
    def add_user(self, user_id: int, username: str):
        self.cursor.execute('INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)', 
                          (user_id, username))
        self.conn.commit()
    
    def is_admin(self, user_id: int) -> bool:
        self.cursor.execute('SELECT role FROM staff WHERE user_id = ?', (user_id,))
        return self.cursor.fetchone() is not None
    
    def add_nft(self, name: str, price: float, link: str):
        self.cursor.execute('INSERT INTO nft_items (name, price, link) VALUES (?, ?, ?)', 
                          (name, price, link))
        self.conn.commit()
    
    def get_nft_items(self):
        self.cursor.execute('SELECT id, name, price, link FROM nft_items')
        return [
            {'id': row[0], 'name': row[1], 'price': row[2], 'link': row[3]}
            for row in self.cursor.fetchall()
        ]
    
    def create_order(self, user_id: int, order_type: str, details: str = ""):
        self.cursor.execute(
            'INSERT INTO orders (user_id, order_type, details) VALUES (?, ?, ?)',
            (user_id, order_type, details)
        )
        self.conn.commit()
        return self.cursor.lastrowid
    
    def update_order_status(self, order_id: int, status: str):
        self.cursor.execute('UPDATE orders SET status = ? WHERE id = ?', (status, order_id))
        self.conn.commit()
    
    def get_order(self, order_id: int):
        self.cursor.execute('SELECT * FROM orders WHERE id = ?', (order_id,))
        row = self.cursor.fetchone()
        if row:
            columns = [desc[0] for desc in self.cursor.description]
            return dict(zip(columns, row))
        return None

db = Database()

# –£—Ç–∏–ª–∏—Ç—ã
async def send_to_admins(text: str, keyboard: InlineKeyboardMarkup = None):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É –∞–¥–º–∏–Ω–æ–≤"""
    try:
        if ADMIN_GROUP_ID:
            await bot.send_message(ADMIN_GROUP_ID, text, reply_markup=keyboard, parse_mode="Markdown")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–¥–º–∏–Ω–∞–º: {e}")

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
def get_main_menu(user_id: int):
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
    buttons = [
        [InlineKeyboardButton(text=f"{EMOJI['nft']} –ö—É–ø–∏—Ç—å NFT", callback_data="buy_nft")],
        [InlineKeyboardButton(text=f"{EMOJI['stars']} –ö—É–ø–∏—Ç—å –∑–≤–µ–∑–¥—ã", callback_data="buy_stars")],
        [InlineKeyboardButton(text=f"{EMOJI['premium']} –ö—É–ø–∏—Ç—å –ø—Ä–µ–º–∏—É–º", callback_data="buy_premium")],
        [InlineKeyboardButton(text=f"{EMOJI['support']} –ü–æ–¥–¥–µ—Ä–∂–∫–∞", callback_data="support")]
    ]
    
    if db.is_admin(user_id):
        buttons.append([InlineKeyboardButton(text=f"{EMOJI['admin']} –ê–¥–º–∏–Ω", callback_data="admin")])
    
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_order_keyboard(order_id: int):
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –∑–∞–∫–∞–∑–∞"""
    buttons = [
        [
            InlineKeyboardButton(text="‚úÖ –í–∑—è—Ç—å", callback_data=f"take_{order_id}"),
            InlineKeyboardButton(text="‚ùå –°–ü–ê–ú", callback_data=f"spam_{order_id}")
        ],
        [
            InlineKeyboardButton(text="üí∞ –ù–µ –æ–ø–ª–∞—Ç–∏–ª", callback_data=f"nopay_{order_id}"),
            InlineKeyboardButton(text="‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=f"complete_{order_id}")
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

# –ö–æ–º–∞–Ω–¥–∞ /start
@dp.message(Command("start"))
async def start_cmd(message: Message, state: FSMContext):
    user_id = message.from_user.id
    username = message.from_user.username or f"user_{user_id}"
    
    # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –ë–î
    db.add_user(user_id, username)
    
    # –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    welcome_text = f"""
{EMOJI['main']} *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç–∞!* {EMOJI['main']}

‚ú® *–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:*
‚Ä¢ {EMOJI['nft']} –ö—É–ø–∏—Ç—å NFT –ø–æ–¥–∞—Ä–∫–∏
‚Ä¢ {EMOJI['stars']} –ö—É–ø–∏—Ç—å Telegram Stars
‚Ä¢ {EMOJI['premium']} –ö—É–ø–∏—Ç—å Telegram Premium
‚Ä¢ {EMOJI['support']} –û–±—Ä–∞—Ç–∏—Ç—å—Å—è –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É

‚ö° *–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π —Ä–∞–∑–¥–µ–ª:*
    """
    
    await state.set_state(UserStates.main_menu)
    await message.answer(
        welcome_text,
        reply_markup=get_main_menu(user_id),
        parse_mode="Markdown"
    )

# –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥"
@dp.callback_query(F.data == "back")
async def back_to_menu(callback: CallbackQuery, state: FSMContext):
    await state.set_state(UserStates.main_menu)
    await callback.message.edit_text(
        f"{EMOJI['main']} *–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=get_main_menu(callback.from_user.id),
        parse_mode="Markdown"
    )

# NFT
@dp.callback_query(F.data == "buy_nft")
async def buy_nft(callback: CallbackQuery, state: FSMContext):
    await state.set_state(UserStates.buy_nft)
    
    nft_items = db.get_nft_items()
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å NFT
    buttons = []
    for item in nft_items:
        buttons.append([
            InlineKeyboardButton(
                text=f"{item['name']} | {item['price']}$", 
                callback_data=f"nft_{item['id']}"
            )
        ])
    
    buttons.append([InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="back")])
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    
    text = f"{EMOJI['nft']} *NFT –ø–æ–¥–∞—Ä–∫–∏*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–∞—Ä–æ–∫:"
    await callback.message.edit_text(text, reply_markup=keyboard, parse_mode="Markdown")

@dp.callback_query(F.data.startswith("nft_"))
async def select_nft(callback: CallbackQuery):
    nft_id = int(callback.data.split("_")[1])
    nft_items = db.get_nft_items()
    
    # –ù–∞—Ö–æ–¥–∏–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π NFT
    item = None
    for nft in nft_items:
        if nft['id'] == nft_id:
            item = nft
            break
    
    if item:
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üõí –ö—É–ø–∏—Ç—å", callback_data=f"buynft_{nft_id}")],
            [InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="buy_nft")]
        ])
        
        await callback.message.edit_text(
            f"{EMOJI['nft']} *{item['name']}*\n\n"
            f"üí∞ *–¶–µ–Ω–∞:* {item['price']}$\n"
            f"üîó *–°—Å—ã–ª–∫–∞:* {item['link']}\n\n"
            f"–ù–∞–∂–º–∏—Ç–µ '–ö—É–ø–∏—Ç—å' –¥–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞.",
            reply_markup=keyboard,
            parse_mode="Markdown"
        )

@dp.callback_query(F.data.startswith("buynft_"))
async def buy_nft_item(callback: CallbackQuery):
    nft_id = int(callback.data.split("_")[1])
    user = callback.from_user
    
    # –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑
    order_id = db.create_order(
        user_id=user.id,
        order_type="nft",
        details=f"NFT ID: {nft_id}"
    )
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤
    order_text = f"""
üÜï *–ù–û–í–´–ô –ó–ê–ö–ê–ó –ù–ê NFT*

üìã *–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*
‚Ä¢ –ù–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞: #{order_id}
‚Ä¢ ID –∫–ª–∏–µ–Ω—Ç–∞: `{user.id}`
‚Ä¢ –ò–º—è: {user.first_name}
‚Ä¢ –ù–∏–∫: @{user.username or '–ù–µ—Ç'}
‚Ä¢ –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
‚Ä¢ –°—Ç–∞—Ç—É—Å: ‚ùå –ù–µ –≤–∑—è—Ç
    """
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞–¥–º–∏–Ω–∞–º
    await send_to_admins(order_text, get_order_keyboard(order_id))
    
    # –û—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    await callback.message.edit_text(
        f"{EMOJI['success']} *–ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω!*\n\n"
        f"–í–∞—à –∑–∞–∫–∞–∑ #{order_id} –ø—Ä–∏–Ω—è—Ç.\n"
        f"–° –≤–∞–º–∏ —Å–∫–æ—Ä–æ —Å–≤—è–∂–µ—Ç—Å—è –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –æ–ø–ª–∞—Ç—ã.",
        parse_mode="Markdown"
    )

# –ó–≤–µ–∑–¥—ã
@dp.callback_query(F.data == "buy_stars")
async def buy_stars(callback: CallbackQuery):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="50 –∑–≤–µ–∑–¥ - 99‚ÇΩ", callback_data="stars_50")],
        [InlineKeyboardButton(text="100 –∑–≤–µ–∑–¥ - 199‚ÇΩ", callback_data="stars_100")],
        [InlineKeyboardButton(text="300 –∑–≤–µ–∑–¥ - 499‚ÇΩ", callback_data="stars_300")],
        [InlineKeyboardButton(text="500 –∑–≤–µ–∑–¥ - 999‚ÇΩ", callback_data="stars_500")],
        [InlineKeyboardButton(text="1000 –∑–≤–µ–∑–¥ - 1999‚ÇΩ", callback_data="stars_1000")],
        [InlineKeyboardButton(text="5000 –∑–≤–µ–∑–¥ - 4299‚ÇΩ", callback_data="stars_5000")],
        [InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="back")]
    ])
    
    await callback.message.edit_text(
        f"{EMOJI['stars']} *Telegram Stars*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤–µ–∑–¥:",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@dp.callback_query(F.data.startswith("stars_"))
async def select_stars(callback: CallbackQuery):
    stars = callback.data.split("_")[1]
    user = callback.from_user
    
    # –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑
    order_id = db.create_order(
        user_id=user.id,
        order_type="stars",
        details=f"Stars: {stars}"
    )
    
    # –°–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞–º
    order_text = f"""
üÜï *–ù–û–í–´–ô –ó–ê–ö–ê–ó –ù–ê STARS*

üìã *–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*
‚Ä¢ –ù–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞: #{order_id}
‚Ä¢ ID –∫–ª–∏–µ–Ω—Ç–∞: `{user.id}`
‚Ä¢ –ò–º—è: {user.first_name}
‚Ä¢ –ù–∏–∫: @{user.username or '–ù–µ—Ç'}
‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {stars} –∑–≤–µ–∑–¥
‚Ä¢ –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
‚Ä¢ –°—Ç–∞—Ç—É—Å: ‚ùå –ù–µ –≤–∑—è—Ç
    """
    
    await send_to_admins(order_text, get_order_keyboard(order_id))
    
    await callback.message.edit_text(
        f"{EMOJI['success']} *–ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω!*\n\n"
        f"–ó–∞–∫–∞–∑ –Ω–∞ {stars} –∑–≤–µ–∑–¥ –ø—Ä–∏–Ω—è—Ç.\n"
        f"–° –≤–∞–º–∏ —Å–∫–æ—Ä–æ —Å–≤—è–∂–µ—Ç—Å—è –º–µ–Ω–µ–¥–∂–µ—Ä.",
        parse_mode="Markdown"
    )

# –ü—Ä–µ–º–∏—É–º
@dp.callback_query(F.data == "buy_premium")
async def buy_premium(callback: CallbackQuery):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="1 –º–µ—Å—è—Ü - 6.2$", callback_data="premium_1")],
        [InlineKeyboardButton(text="3 –º–µ—Å—è—Ü–∞ - 10$", callback_data="premium_3")],
        [InlineKeyboardButton(text="6 –º–µ—Å—è—Ü–µ–≤ - 18$", callback_data="premium_6")],
        [InlineKeyboardButton(text="1 –≥–æ–¥ - 35$", callback_data="premium_12")],
        [InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="back")]
    ])
    
    await callback.message.edit_text(
        f"{EMOJI['premium']} *Telegram Premium*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –ø–æ–¥–ø–∏—Å–∫–∏:",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

@dp.callback_query(F.data.startswith("premium_"))
async def select_premium(callback: CallbackQuery):
    period = callback.data.split("_")[1]
    user = callback.from_user
    
    periods = {
        "1": "1 –º–µ—Å—è—Ü",
        "3": "3 –º–µ—Å—è—Ü–∞",
        "6": "6 –º–µ—Å—è—Ü–µ–≤",
        "12": "1 –≥–æ–¥"
    }
    
    period_text = periods.get(period, period)
    
    # –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑
    order_id = db.create_order(
        user_id=user.id,
        order_type="premium",
        details=f"Premium: {period_text}"
    )
    
    # –°–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞–º
    order_text = f"""
üÜï *–ù–û–í–´–ô –ó–ê–ö–ê–ó –ù–ê PREMIUM*

üìã *–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*
‚Ä¢ –ù–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞: #{order_id}
‚Ä¢ ID –∫–ª–∏–µ–Ω—Ç–∞: `{user.id}`
‚Ä¢ –ò–º—è: {user.first_name}
‚Ä¢ –ù–∏–∫: @{user.username or '–ù–µ—Ç'}
‚Ä¢ –ü–µ—Ä–∏–æ–¥: {period_text}
‚Ä¢ –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
‚Ä¢ –°—Ç–∞—Ç—É—Å: ‚ùå –ù–µ –≤–∑—è—Ç
    """
    
    await send_to_admins(order_text, get_order_keyboard(order_id))
    
    await callback.message.edit_text(
        f"{EMOJI['success']} *–ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω!*\n\n"
        f"–ó–∞–∫–∞–∑ –Ω–∞ Telegram Premium ({period_text}) –ø—Ä–∏–Ω—è—Ç.\n"
        f"–° –≤–∞–º–∏ —Å–∫–æ—Ä–æ —Å–≤—è–∂–µ—Ç—Å—è –º–µ–Ω–µ–¥–∂–µ—Ä.",
        parse_mode="Markdown"
    )

# –ü–æ–¥–¥–µ—Ä–∂–∫–∞
@dp.callback_query(F.data == "support")
async def support(callback: CallbackQuery):
    user = callback.from_user
    
    # –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑ –ø–æ–¥–¥–µ—Ä–∂–∫–∏
    order_id = db.create_order(
        user_id=user.id,
        order_type="support",
        details="–ó–∞–ø—Ä–æ—Å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É"
    )
    
    # –°–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞–º
    order_text = f"""
üÜï *–ù–û–í–´–ô –ó–ê–ü–†–û–° –í –ü–û–î–î–ï–†–ñ–ö–£*

üìã *–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*
‚Ä¢ –ù–æ–º–µ—Ä –∑–∞–ø—Ä–æ—Å–∞: #{order_id}
‚Ä¢ ID –∫–ª–∏–µ–Ω—Ç–∞: `{user.id}`
‚Ä¢ –ò–º—è: {user.first_name}
‚Ä¢ –ù–∏–∫: @{user.username or '–ù–µ—Ç'}
‚Ä¢ –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
‚Ä¢ –°—Ç–∞—Ç—É—Å: ‚ùå –ù–µ –≤–∑—è—Ç
    """
    
    await send_to_admins(order_text, get_order_keyboard(order_id))
    
    await callback.message.edit_text(
        f"{EMOJI['success']} *–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!*\n\n"
        f"–í–∞—à –∑–∞–ø—Ä–æ—Å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É –ø—Ä–∏–Ω—è—Ç.\n"
        f"–û–∂–∏–¥–∞–π—Ç–µ –æ—Ç–≤–µ—Ç–∞ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.",
        parse_mode="Markdown"
    )

# –ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å
@dp.callback_query(F.data == "admin")
async def admin_panel(callback: CallbackQuery, state: FSMContext):
    user_id = callback.from_user.id
    
    if not db.is_admin(user_id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏!", show_alert=True)
        return
    
    await state.set_state(AdminStates.admin_menu)
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å NFT", callback_data="add_nft")],
        [InlineKeyboardButton(text=f"{EMOJI['back']} –ù–∞–∑–∞–¥", callback_data="back")]
    ])
    
    await callback.message.edit_text(
        f"{EMOJI['admin']} *–ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

# –î–æ–±–∞–≤–ª–µ–Ω–∏–µ NFT
@dp.callback_query(F.data == "add_nft")
async def add_nft_start(callback: CallbackQuery, state: FSMContext):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    await state.set_state(AdminStates.add_nft_name)
    await callback.message.edit_text(
        f"{EMOJI['nft']} *–î–æ–±–∞–≤–ª–µ–Ω–∏–µ NFT*\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–æ–¥–∞—Ä–∫–∞:",
        parse_mode="Markdown"
    )

@dp.message(AdminStates.add_nft_name)
async def add_nft_name(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(AdminStates.add_nft_price)
    await message.answer(f"{EMOJI['money']} –í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É –≤ $:")

@dp.message(AdminStates.add_nft_price)
async def add_nft_price(message: Message, state: FSMContext):
    try:
        price = float(message.text)
        await state.update_data(price=price)
        await state.set_state(AdminStates.add_nft_link)
        await message.answer(f"üîó –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ–¥–∞—Ä–æ–∫:")
    except ValueError:
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ! –ù–∞–ø—Ä–∏–º–µ—Ä: 100")

@dp.message(AdminStates.add_nft_link)
async def add_nft_link(message: Message, state: FSMContext):
    data = await state.get_data()
    
    # –î–æ–±–∞–≤–ª—è–µ–º NFT –≤ –ë–î
    db.add_nft(data['name'], data['price'], message.text)
    
    await message.answer(
        f"{EMOJI['success']} NFT '{data['name']}' –¥–æ–±–∞–≤–ª–µ–Ω!\n"
        f"–¶–µ–Ω–∞: {data['price']}$\n"
        f"–°—Å—ã–ª–∫–∞: {message.text}"
    )
    
    await state.clear()

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫–∞–∑–æ–≤ –∞–¥–º–∏–Ω–∞–º–∏
@dp.callback_query(F.data.startswith("take_"))
async def take_order(callback: CallbackQuery):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    order_id = int(callback.data.split("_")[1])
    db.update_order_status(order_id, "b")  # –í –ø—Ä–æ—Ü–µ—Å—Å–µ
    
    order = db.get_order(order_id)
    if order:
        text = f"""
üîÑ *–ó–ê–ö–ê–ó –í –†–ê–ë–û–¢–ï* #{order_id}

üìã *–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*
‚Ä¢ ID –∫–ª–∏–µ–Ω—Ç–∞: `{order['user_id']}`
‚Ä¢ –¢–∏–ø: {order['order_type']}
‚Ä¢ –í–∑—è–ª: @{callback.from_user.username}
‚Ä¢ –°—Ç–∞—Ç—É—Å: üîÑ –í –ø—Ä–æ—Ü–µ—Å—Å–µ
        """
        
        await callback.message.edit_text(text, parse_mode="Markdown")
    
    await callback.answer("‚úÖ –ó–∞–∫–∞–∑ –≤–∑—è—Ç –≤ —Ä–∞–±–æ—Ç—É!")

@dp.callback_query(F.data.startswith("complete_"))
async def complete_order(callback: CallbackQuery):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    order_id = int(callback.data.split("_")[1])
    db.update_order_status(order_id, "s")  # –ó–∞–≤–µ—Ä—à–µ–Ω–æ
    await callback.answer("‚úÖ –ó–∞–∫–∞–∑ –∑–∞–≤–µ—Ä—à–µ–Ω!")

@dp.callback_query(F.data.startswith("spam_"))
async def spam_order(callback: CallbackQuery):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    order_id = int(callback.data.split("_")[1])
    db.update_order_status(order_id, "z")  # –°–ø–∞–º
    
    order = db.get_order(order_id)
    if order:
        try:
            await bot.send_message(
                order['user_id'], 
                f"{EMOJI['error']} –û—à–∏–±–∫–∞. –°–≤—è–∑—å —Å –±–∞–∑–æ–π..."
            )
        except:
            pass
    
    await callback.answer("üö´ –ü–æ–º–µ—á–µ–Ω–æ –∫–∞–∫ —Å–ø–∞–º!")

@dp.callback_query(F.data.startswith("nopay_"))
async def nopay_order(callback: CallbackQuery):
    if not db.is_admin(callback.from_user.id):
        await callback.answer("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞!", show_alert=True)
        return
    
    order_id = int(callback.data.split("_")[1])
    db.update_order_status(order_id, "g")  # –ù–µ –æ–ø–ª–∞—Ç–∏–ª
    
    order = db.get_order(order_id)
    if order:
        try:
            await bot.send_message(
                order['user_id'], 
                f"{EMOJI['error']} –í–´ –Ω–µ –æ–ø–ª–∞—Ç–∏–ª–∏ –∑–∞–∫–∞–∑. –û–ø–ª–∞—Ç–∏—Ç–µ –ø–æ–∂–∞–ª—É–π—Å—Ç–∞."
            )
        except:
            pass
    
    await callback.answer("üí∞ –û—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ '–ù–µ –æ–ø–ª–∞—Ç–∏–ª'")

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def main():
    print("=" * 50)
    print("ü§ñ –ë–û–¢ –ó–ê–ü–£–©–ï–ù!")
    print(f"üëë –í–ª–∞–¥–µ–ª–µ—Ü: {OWNER_ID}")
    print(f"üë• –ì—Ä—É–ø–ø–∞ –∞–¥–º–∏–Ω–æ–≤: {ADMIN_GROUP_ID if ADMIN_GROUP_ID else '–ù–µ —É–∫–∞–∑–∞–Ω–∞'}")
    print("=" * 50)
    print("\nüìù –ö–æ–º–∞–Ω–¥—ã –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:")
    print("1. –û—Ç–ø—Ä–∞–≤—å—Ç–µ /start –±–æ—Ç—É")
    print("2. –ù–∞–∂–º–∏—Ç–µ '–ö—É–ø–∏—Ç—å NFT'")
    print("3. –í—ã–±–µ—Ä–∏—Ç–µ –ª—é–±–æ–π NFT")
    print("4. –ù–∞–∂–º–∏—Ç–µ '–ö—É–ø–∏—Ç—å'")
    print("5. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≥—Ä—É–ø–ø—É –∞–¥–º–∏–Ω–æ–≤ (–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞)")
    print("=" * 50)
    
    await dp.start_polling(bot)

if __name__ == "__main__":
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞: {e}")
    finally:
        # –ó–∞–∫—Ä—ã–≤–∞–µ–º –ë–î
        try:
            db.conn.close()
        except:
            pass
